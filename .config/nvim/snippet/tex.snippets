# Thank you to Gilles Castel, the man is a lifesaver
#
# For reference:
# b: Beginning of line
# i: In-word expansion (OK)
# w: Word expansion (followed by nonwords on both sides)
# r: Regex
# t: Don't expand tabs
# s: Remove whitespace immediately before cursor at end of line
# m: Trim all whitespace from right side of snippet lines
# e: Custom context snippet
# A: Automatically trigger snippet

global !p
texMathZones = ['texMathZone' + x for x in ['A', 'AS', 'B', 'BS', 'C', 'CS', 'D', 'DS', 'E', 'ES', 'F', 'FS', 'G', 'GS', 'H', 'HS', 'I', 'IS', 'J', 'JS', 'K', 'KS', 'L', 'LS', 'DS', 'V', 'W', 'X', 'Y', 'Z', 'AmsA', 'AmsB', 'AmsC', 'AmsD', 'AmsE', 'AmsF', 'AmsG', 'AmsAS', 'AmsBS', 'AmsCS', 'AmsDS', 'AmsES', 'AmsFS', 'AmsGS' ]]
texIgnoreMathZones = ['texMathText']
texMathZoneIds = vim.eval('map('+str(texMathZones)+", 'hlID(v:val)')")
texIgnoreMathZoneIds = vim.eval('map('+str(texIgnoreMathZones)+", 'hlID(v:val)')")
ignore = texIgnoreMathZoneIds[0]
def math():
	synstackids = vim.eval("synstack(line('.'), col('.') - (col('.')>=2 ? 1 : 0))")
	try:
		first = next(i for i in reversed(synstackids) if i in texIgnoreMathZoneIds or i in texMathZoneIds)
		return first != ignore
	except StopIteration:
		return False
endglobal

snippet doc "template" b
\documentclass{article}
\usepackage{amsmath, amssymb, amsthm}
\newtheorem{theorem}{Theorem}
\newtheorem{definition}{Definition}
\newtheorem{lemma}{Lemma}
\renewcommand\qedsymbol{$\boxtimes$}
\begin{document}
    $0
\end{document}
endsnippet

snippet titlepage "title page"
\begin{titlepage}
    \begin{center}
        \vspace*{1cm}
 
        \Huge
        \textbf{$1}
 
        \vspace{0.5cm}
        \LARGE
    	$2

        \vspace{1.5cm}
 
        \textbf{Simon Xiang}
 
        \vfill
  
        \vspace{0.8cm}
 
        \Large
    	$3\\\
        University of Texas at Austin\\\
        \today
 
    \end{center}
\end{titlepage}
$0
endsnippet

snippet beg "begin{} / end{}" bA
\\begin{$1}
    $2
\\end{$1}
$0
endsnippet

snippet mm "inline math mode" wA
$${1}$`!p
if t[2] and t[2][0] not in [',', '.',':', '?', '-', ' ']:
    snip.rv = ' ' 
else:
    snip.rv = ''
`$2
endsnippet

context "math()"
snippet '([A-Za-z])(\d)' "auto subscript" wrA
`!p snip.rv = match.group(1)`_`!p snip.rv = match.group(2)`
endsnippet

context "math()"
snippet '([A-Za-z])_(\d\d)' "auto subscript2" wrA
`!p snip.rv = match.group(1)`_{`!p snip.rv = match.group(2)`}
endsnippet

snippet eq "equation" w
\[
$1
\]
$0
endsnippet

snippet enum "enumerate" bA
\begin{enumerate}
    \item $0
\end{enumerate}
endsnippet

snippet item "itemize" bA
\begin{itemize}
    \item $0
\end{itemize}
endsnippet

snippet defn "definition" 
\emph{${1:${VISUAL}}} $0
endsnippet

snippet def "definition environment" b
\begin{definition}${1:[$2]}
    $3
\end{definition}$0
endsnippet

snippet => "implies" Ai
\implies 
endsnippet

snippet <= "implied by" Ai
\impliedby 
endsnippet

context "math()"
snippet ceil "ceil" iA
\left\lceil $1 \right\rceil $0
endsnippet

context "math()"
snippet floor "floor" iA
\left\lfloor $1 \right\rfloor$0
endsnippet

context "math()"
snippet <> "angle brackets" iA
\langle ${1:${VISUAL}} \rangle $0
endsnippet

context "math()"
snippet () "left( right)" iA
\left( ${1:${VISUAL}} \right) $0
endsnippet

snippet lr "left( right)" i
\left( ${1:${VISUAL}} \right) $0
endsnippet

snippet lr( "left( right)" i
\left( ${1:${VISUAL}} \right) $0
endsnippet

snippet lr| "left| right|" i
\left| ${1:${VISUAL}} \right| $0
endsnippet

snippet lr{ "left\{ right\}" i
\left\\{ ${1:${VISUAL}} \right\\} $0
endsnippet

snippet lrb "left\{ right\}" i
\left\\{ ${1:${VISUAL}} \right\\} $0
endsnippet

snippet lr[ "left[ right]" i
\left[ ${1:${VISUAL}} \right] $0
endsnippet

snippet lra "leftangle rightangle" iA
\left<${1:${VISUAL}} \right>$0
endsnippet

context "math()"
snippet sq "\sqrt{}" iA
\sqrt{${1:${VISUAL}}} $0
endsnippet

context "math()"
snippet sr "squared" iA
^2
endsnippet

context "math()"
snippet cb "cubed" iA
^3
endsnippet

context "math()"
snippet comp "complement" iA
^{c}
endsnippet

context "math()"
snippet invs "inverse" iA
^{-1}
endsnippet

# tot -> to the {something}

context "math()"
snippet tot "superscript" iA
^{$1}$0
endsnippet

context "math()"
snippet sbs "subscript" iA
_{$1}$0
endsnippet

context "math()"
snippet // "fraction" iA
\\frac{$1}{$2}$0
endsnippet

context "math()"
snippet '((\d+)|(\d*)(\\)?([A-Za-z]+)((\^|_)(\{\d+\}|\d))*)/' "Fraction" wrA
\\frac{`!p snip.rv = match.group(1)`}{$1}$0
endsnippet

context "math()"
snippet ddt "d/dt" iA
\frac{d}{dt} 
endsnippet

context "math()"
snippet dint "definite integral" wA
\int_{${1:\infty}}^{${2:\infty}} ${3:${VISUAL}} \, d$0
endsnippet

context "math()"
snippet indl "indefinite integral" wA
\int ${1:${VISUAL}} \, d$0
endsnippet

context "math()"
snippet Re "real part" wA
\operatorname{Re}$0
endsnippet

context "math()"
snippet Im "complex part" wA
\operatorname{Im}$0
endsnippet

context "math()"
snippet GL "general linear group" wA
\operatorname{GL}_
endsnippet

context "math()"
snippet SL "special linear group" wA
\operatorname{SL}_
endsnippet

context "math()"
snippet map "map" A
$1 \colon $2 \to $0
endsnippet

snippet sum "sum" w
\sum_{n=${1:1}}^{${2:\infty}} ${3:a_n x^n}
endsnippet

context "math()"
snippet cc "subset" Ai
\subseteq
endsnippet

context "math()"
snippet inn "in " iA
\in 
endsnippet

context "math()"
snippet NN "n" iA
\N
endsnippet

context "math()"
snippet Nn "cap" iA
\cap 
endsnippet

context "math()"
snippet UU "cup" iA
\cup 
endsnippet

context "math()"
snippet uuu "bigcup" iA
\bigcup_{${1:i \in ${2: I}}} $0
endsnippet

context "math()"
snippet nnn "bigcap" iA
\bigcap_{${1:i \in ${2: I}}} $0
endsnippet

context "math()"
snippet OO "emptyset" iA
\O
endsnippet

context "math()"
snippet RR "real" iA
\R
endsnippet

context "math()"
snippet QQ "Q" iA
\Q
endsnippet

context "math()"
snippet ZZ "Z" iA
\Z
endsnippet

context "math()"
snippet set "set" wA
\\{$1\\} $0
endsnippet

context "math()"
snippet || "mid" iA
 \mid 
endsnippet

context "math()"
snippet xx "cross" iA
\times 
endsnippet

context "math()"
snippet ** "cdot" iA
\cdot 
endsnippet

context "math()"
snippet znz "Z/nZ" iA
\Z /n\Z
endsnippet

context "math()"
snippet \\\ "setminus" iA
\setminus
endsnippet

snippet difeq "differential equation" iA
differential equation 
endsnippet

priority 1000
context "math()"
snippet S1 "S1" iA
S^{1} 
endsnippet

snippet subsec "subsection" bA
\subsection{$1}
$0
endsnippet

snippet prob "unnumbered problem env" bA
\\begin{prob}
    $1
\\end{prob}
$0
endsnippet
